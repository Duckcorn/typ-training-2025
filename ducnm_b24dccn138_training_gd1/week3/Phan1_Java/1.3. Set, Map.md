# 1.Set
> Trong Java, giao diện Set là một phần của Java Collection Framework, nằm trong gói java.util. Nó đại diện cho một tập hợp các phần tử duy nhất, nghĩa là không cho phép các giá trị trùng lặp.
> - Giao diện Set không cho phép phần tử trùng lặp.
> - Nó chỉ có thể chứa tối đa một giá trị null, ngoại trừ TreeSet (không cho phép giá trị null).
> - Set cung cấp hiệu suất cao trong các thao tác tìm kiếm, chèn và xóa phần tử.

**Cấu trúc phân cấp của giao diện Set trong Java**
<img width="1021" height="236" alt="Screenshot 2025-11-09 101234" src="https://github.com/user-attachments/assets/c25e33fd-7a3f-4453-b775-7ebc4c4e7304" />

**Các lớp triển khai giao diện Set trong Java:**
- HashSet: Một tập Set lưu trữ các phần tử duy nhất mà không theo thứ tự cụ thể nào, dựa trên bảng băm (hash table), cho phép chứa một giá trị NULL.
- EnumSet: Là một tập hợp hiệu năng cao được thiết kế đặc biệt cho các kiểu enum, tất cả các phần tử phải thuộc cùng một kiểu enum.
- LinkedHashSet: Lưu trữ các phần tử duy nhất, đồng thời duy trì thứ tự chèn (insertion order).
- TreeSet: Lưu trữ các phần tử duy nhất theo thứ tự được sắp xếp, có thể sắp xếp theo thứ tự tự nhiên (natural order) hoặc theo Comparator được chỉ định.

**Tạo ra phần tử Set**
```java
// Obj is the type of the object to be stored in Set 
Set<Obj> set = new HashSet<Obj> ();
```
## 1.1. Adding Elements
- Để thêm một phần tử vào trong Set, ta dùng phương thức add()
**Ví dụ**
```java
import java.util.Scanner;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Set<String> s = new HashSet<String>();
        s.add("B");
        s.add("B");
        s.add("C");
        s.add("A");
        System.out.println(s); // -> [A,B,C]
        scanner.close();
    }
}
```

## 1.2. Accessing the Elements
- Sau khi thêm các phần tử, nếu muốn truy cập hoặc kiểm tra các phần tử, chúng ta có thể sử dụng các phương thức có sẵn (inbuilt methods) như contains().
**Ví dụ**
```java
import java.util.Scanner;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Set<String> h = new HashSet<String>();
        h.add("A");
        h.add("B");
        h.add("C");
        h.add("A");
        System.out.println("Set is " + h);
        String s = "D";
        System.out.println("Contains " + s + " " + h.contains(s));  // ->Set is [A, B, C]
                                                                        Contains D false
        scanner.close();
    }
}
```

## 1.3. Removing Elements
- Có thể loại bỏ phần tử trong Set bằng phương thức remove()
**Ví dụ**
```java
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Set<String> h = new HashSet<String>();
        h.add("A");
        h.add("B");
        h.add("C");
        h.add("B");
        h.add("D");
        h.add("E");
        System.out.println("Initial HashSet " + h);
        h.remove("B");
        System.out.println("After removing element " + h); // -> Initial HashSet [A, B, C, D, E]
                                                                 After removing element [A, C, D, E]
        scanner.close();
    }
}
```

## 1.4. Iteratin
- Có nhiều cách để duyệt qua các phần tử trong Set. Cách phổ biến nhất là sử dụng vòng lặp for nâng cao (enhanced for loop).
**Ví dụ**
```java
import java.util.Scanner;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Set<String> h = new HashSet<String>();
        h.add("A");
        h.add("B");
        h.add("C");
        h.add("B");
        h.add("D");
        h.add("E");
        for (String value : h)
            System.out.print(value + ", "); // -> A,B,C,D,E,
        System.out.println();
        scanner.close();
    }
}
```

**Các phương thức chính của giao diện Set**
<img width="845" height="785" alt="Screenshot 2025-11-09 104450" src="https://github.com/user-attachments/assets/af3b54bd-c15b-4409-b938-642c75c9477b" />


# 2.Map
> Trong Java, giao diện Map là một phần của gói java.util và đại diện cho một tập hợp các cặp khóa-giá trị (key-value pairs), trong đó: Khóa (key) phải là duy nhất, nhưng giá trị (value) có thể trùng lặp.
> - Cung cấp các thao tác truy xuất, chèn và xóa hiệu quả dựa trên khóa.
> - Khóa phải duy nhất, nhưng giá trị có thể trùng lặp.
> - HashMap và LinkedHashMap cho phép một khóa null, trong khi TreeMap không cho phép khóa null nếu sử dụng thứ tự tự nhiên (natural ordering).
> - Sử dụng ConcurrentHashMap để thực hiện các thao tác an toàn với nhiều luồng (thread-safe), hoặc Collections.synchronizedMap() để biến một Map hiện có thành đồng bộ.

**Khai báo Map**
```java
public interface Map<K, V>
```
- K → Kiểu dữ liệu của khóa (Key) được lưu trữ trong Map.
- V → Kiểu dữ liệu của giá trị (Value) được ánh xạ với các khóa trong Map.

**Tạo đối tượng Map**
- Vì Map là một giao diện (interface), chúng ta không thể tạo trực tiếp đối tượng Map. Thay vào đó, phải sử dụng một lớp triển khai Map, ví dụ: HashMap, TreeMap, LinkedHashMap,...
```java
Map<String, Integer> hm = new HashMap<>();
```

**Ví dụ**
```java
import java.util.Scanner;
import java.util.*;
/*
Toi ten la Ngo Minh Duc
 */

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Map<String, Integer> m = new HashMap<>();
        m.put("duc", 1);
        m.put("binh", 2);
        m.put("thao", 3);
        System.out.println("Map elements: " + m);   // -> Map elements: {duc=1, thao=3, binh=2}
        scanner.close();
    }
}
```

**Cấu trúc phân cấp của Map trong java**
-Map là một phần của Java Collections Framework và được triển khai bởi nhiều lớp khác nhau. Sơ đồ phân cấp cơ bản:
<img width="811" height="407" alt="Screenshot 2025-11-09 110646" src="https://github.com/user-attachments/assets/81c7086d-a4cf-4bdc-af47-d5cf5bc5f58e" />

**Các lớp triển khai của giao diện Map trong Java**
- Hashmap: Lưu trữ các cặp khóa-giá trị (key-value pairs) sử dụng hashing, cho phép truy xuất, chèn và xóa nhanh.
- LinkedHashMap: Tương tự HashMap, nhưng duy trì thứ tự chèn (insertion order) của các khóa, hiệu quả khi cần lặp qua các phần tử theo thứ tự chèn.
- TreeMap: Lưu trữ các cặp key-value theo thứ tự sắp xếp (natural order hoặc theo Comparator tùy chỉnh).
- Hashtable: Lớp đồng bộ (synchronized), an toàn với nhiều luồng (thread-safe), không cho phép khóa hoặc giá trị null.

## Các thao tác cơ bản trên Map sử dụng HashMap:

## 2.1. Adding Elements
- Sử dụng phương thức put() để thêm phần tử vào Map. Trong HashMap, thứ tự chèn (insertion order) không được giữ nguyên. Mỗi phần tử được lưu trữ dựa trên giá trị băm (hash) của khóa, điều này giúp truy xuất, chèn và xóa phần tử nhanh hơn.

**Ví dụ**
```java
import java.util.Scanner;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Map<Integer, String> m1 = new HashMap<>();
        m1.put(1, "Ngo");
        m1.put(2, "Minh");
        m1.put(3, "Duc");
        System.out.println(m1);    // -> {1=Ngo, 2=Minh, 3=Duc}
        scanner.close();
    }
}
```

## 2.2. Changing Element
-Để cập nhật giá trị trong Map, sử dụng lại phương thức put() với cùng một khóa (key).

**Ví dụ**
```java
import java.util.Scanner;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Map<Integer, String> m1 = new HashMap<>();
        m1.put(1, "Ngo");
        m1.put(2, "Minh");
        m1.put(3, "Duc");
        System.out.println(m1); // ->{1=Ngo, 2=Minh, 3=Duc} 
        m1.put(2, "Ok");
        System.out.println(m1); // -> {1=Ngo, 2=Ok, 3=Duc}
        scanner.close();
    }
}
```

## 2.3. Removing Elements
- Để xóa một phần tử khỏi Map, chúng ta có thể sử dụng phương thức remove(). Phương thức này nhận vào một khóa (key) và xóa cặp khóa-giá trị tương ứng khỏi Map nếu khóa đó tồn tại trong Map.

**Ví dụ**
```java
import java.util.Scanner;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Map<Integer, String> m1 = new HashMap<>();
        m1.put(1, "Ngo");
        m1.put(2, "Minh");
        m1.put(3, "Duc");
        System.out.println(m1); // ->{1=Ngo, 2=Minh, 3=Duc}
        m1.remove(3);
        System.out.println(m1); // -> {1=Ngo, 2=Minh}
        scanner.close();
    }
}
```

## 2.4. Iterating through the Map
- Có nhiều cách để duyệt qua các phần tử trong Map. Cách phổ biến nhất là sử dụng vòng lặp for-each và lấy các entry (cặp key-value) từ Map. Giá trị tương ứng với một khóa (key) được lấy bằng cách sử dụng phương thức getValue().

**Ví dụ**
```java
import java.util.Scanner;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Map<Integer, String> m1 = new HashMap<>();
        m1.put(1, "Ngo");
        m1.put(2, "Minh");
        m1.put(3, "Duc");
        for (Map.Entry<Integer, String> entry : m1.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());    // ->Key: 1, Value: Ngo
                                                                                                   Key: 2, Value: Minh
                                                                                                   Key: 3, Value: Duc
        }
        scanner.close();
    }
}
```

**Các phương thức chính trong giao diện Map**



<img width="624" height="800" alt="Screenshot 2025-11-09 112844" src="https://github.com/user-attachments/assets/89a51373-5c7c-4f52-8369-167f4c8f8633" />


